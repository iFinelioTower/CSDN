/*
 * Copyright (C) 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License
 */

package com.android.systemui.statusbar.phone;

import android.app.AlarmManager;
import android.app.PendingIntent;
import android.content.Context;
import android.content.Intent;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.graphics.Outline;
import android.graphics.Rect;
import android.graphics.drawable.Animatable;
import android.graphics.drawable.Drawable;
import android.graphics.drawable.RippleDrawable;
import android.util.AttributeSet;
import android.util.MathUtils;
import android.util.TypedValue;
import android.view.View;
import android.view.ViewGroup;
import android.view.ViewOutlineProvider;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.RelativeLayout;
import android.widget.Switch;
import android.widget.TextView;
import android.widget.Toast;

import com.android.keyguard.KeyguardStatusView;
import com.android.systemui.BatteryMeterView;
import com.android.systemui.FontSizeUtils;
import com.android.systemui.R;
import com.android.systemui.qs.QSPanel;
import com.android.systemui.qs.QSTile;
import com.android.systemui.statusbar.policy.BatteryController;
import com.android.systemui.statusbar.policy.NetworkControllerImpl.EmergencyListener;
import com.android.systemui.statusbar.policy.NextAlarmController;
import com.android.systemui.statusbar.policy.UserInfoController;
import com.android.systemui.tuner.TunerService;

import java.text.NumberFormat;
import android.util.Log;

import com.android.systemui.qs.tiles.WifiTile;
import com.android.systemui.qs.tiles.BluetoothTile;
import com.android.systemui.qs.tiles.AirplaneModeTile;

import com.android.systemui.statusbar.phone.QSTileHost;
import com.android.systemui.statusbar.widget.CombinationITButton;
import com.android.systemui.statusbar.widget.CombinationITButton.OnClickCallbcak;
import android.widget.SeekBar;

/**
 * The view to manage the header area in the expanded status bar.
 */
public class StatusBarHeaderView extends LinearLayout implements View.OnClickListener,
        BatteryController.BatteryStateChangeCallback, NextAlarmController.NextAlarmChangeCallback,
        EmergencyListener {
        
	static final String TAG = "StatusBarHeaderView";
	
	private int mCollapsedHeight;
    private int mExpandedHeight;

	private boolean mExpanded;
	private boolean mListening;
	
	private final Rect mClipBounds = new Rect();

	private float mCurrentT;
	private boolean mCaptureValues;
	private final LayoutValues mCollapsedValues = new LayoutValues();
    private final LayoutValues mExpandedValues = new LayoutValues();
    private final LayoutValues mCurrentValues = new LayoutValues();

	private ActivityStarter mActivityStarter;
	
    public StatusBarHeaderView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

	@Override
    protected void onFinishInflate() {
        super.onFinishInflate();
		loadDimens();
    }

	 private void loadDimens() {
        mCollapsedHeight = getResources().getDimensionPixelSize(R.dimen.status_bar_header_height);
        mExpandedHeight = getResources().getDimensionPixelSize(
                R.dimen.status_bar_header_height_expanded);

		Log.e(TAG, "mExpandedHeight: " + mExpandedHeight + ", mCollapsedHeight: " + mCollapsedHeight);
    }

	public void setActivityStarter(ActivityStarter activityStarter) {
	    mActivityStarter = activityStarter;
    }

	public void setUserInfoController(UserInfoController userInfoController) {
	
    }

	public void setBatteryController(BatteryController batteryController) {
	
    }

	public void setNextAlarmController(NextAlarmController nextAlarmController) {
	
    }

	public int getCollapsedHeight() {
	    Log.e(TAG, "mCollapsedHeight: " + mCollapsedHeight);
        return mCollapsedHeight;
    }

	public int getExpandedHeight() {
	    Log.e(TAG, "mExpandedHeight: " + mExpandedHeight);
        return mExpandedHeight;
    }

	public void setExpanded(boolean expanded) {
        boolean changed = expanded != mExpanded;
        mExpanded = expanded;
		Log.e(TAG, "setExpanded changed:" + changed);
        if (changed) {
            updateEverything();
        }
    }

	public void setExpansion(float t) {
        if (!mExpanded) {
            t = 0f;
        }
        mCurrentT = t;
        float height = mCollapsedHeight + t * (mExpandedHeight - mCollapsedHeight);
        if (height < mCollapsedHeight) {
            height = mCollapsedHeight;
        }
        if (height > mExpandedHeight) {
            height = mExpandedHeight;
        }
        setClipping(height);
        updateLayoutValues(t);
    }

	private void updateLayoutValues(float t) {
        if (mCaptureValues) {
            return;
        }
        mCurrentValues.interpoloate(mCollapsedValues, mExpandedValues, t);
    }

	private void setClipping(float height) {
        mClipBounds.set(getPaddingLeft(), 0, getWidth() - getPaddingRight(), (int) height);
        setClipBounds(mClipBounds);
        invalidateOutline();
    }
	
	public void setListening(boolean listening) {
        if (listening == mListening) {
            return;
        }
        mListening = listening;
        updateListeners();
    }

	private void updateListeners() {
	
    }
	
	public void updateEverything() {
	    updateHeights();
		requestCaptureValues();
    }

	private void requestCaptureValues() {
        mCaptureValues = true;
        requestLayout();
    }

	private void updateHeights() {
        /*
        int height = mExpanded ? mExpandedHeight : mCollapsedHeight;
        ViewGroup.LayoutParams lp = getLayoutParams();
		Log.e(TAG, "lp.height: " + lp.height + ", height: " + height);
        if (lp.height != height) {
            lp.height = height;
            setLayoutParams(lp);
        }
        */
    }
	
	@Override
    protected void onLayout(boolean changed, int l, int t, int r, int b) {
        super.onLayout(changed, l, t, r, b);
		Log.e(TAG, "changed:" + changed + ", l:" + l + ", t:" + t + ", r:" + r + ", b:" + b);
		
        if (mCaptureValues) {
			if (mExpanded) {
                captureLayoutValues(mExpandedValues);
            } else {
                captureLayoutValues(mCollapsedValues);
            }
			
            mCaptureValues = false;
            updateLayoutValues(mCurrentT);
        }
    }

	private void captureLayoutValues(LayoutValues target) {
    }
	
	@Override
    public void onClick(View v) {
        Log.e(TAG, "v:" + v);
    }

	@Override
    public void setEmergencyCallsOnly(boolean show) {

    }

	@Override
    public void onNextAlarmChanged(AlarmManager.AlarmClockInfo nextAlarm) {
    
    }

	@Override
    public void onPowerSaveChanged() {
        // could not care less
    }

	@Override
    public void onBatteryLevelChanged(int level, boolean pluggedIn, boolean charging) {
    
    }

	/**
     * Captures all layout values (position, visibility) for a certain state. This is used for
     * animations.
     */
    private static final class LayoutValues {
        float dateExpandedAlpha;
        float dateCollapsedAlpha;
        float emergencyCallsOnlyAlpha;
        float alarmStatusAlpha;
        float timeScale = 1f;
        float clockY;
        float dateY;
        float avatarScale;
        float avatarX;
        float avatarY;
        float batteryX;
        float batteryY;
        float batteryLevelAlpha;
        float settingsAlpha;
        float settingsTranslation;
        float signalClusterAlpha;
        float settingsRotation;

        public void interpoloate(LayoutValues v1, LayoutValues v2, float t) {
            timeScale = v1.timeScale * (1 - t) + v2.timeScale * t;
            clockY = v1.clockY * (1 - t) + v2.clockY * t;
            dateY = v1.dateY * (1 - t) + v2.dateY * t;
            avatarScale = v1.avatarScale * (1 - t) + v2.avatarScale * t;
            avatarX = v1.avatarX * (1 - t) + v2.avatarX * t;
            avatarY = v1.avatarY * (1 - t) + v2.avatarY * t;
            batteryX = v1.batteryX * (1 - t) + v2.batteryX * t;
            batteryY = v1.batteryY * (1 - t) + v2.batteryY * t;
            settingsTranslation = v1.settingsTranslation * (1 - t) + v2.settingsTranslation * t;

            float t1 = Math.max(0, t - 0.5f) * 2;
            settingsRotation = v1.settingsRotation * (1 - t1) + v2.settingsRotation * t1;
            emergencyCallsOnlyAlpha =
                    v1.emergencyCallsOnlyAlpha * (1 - t1) + v2.emergencyCallsOnlyAlpha * t1;

            float t2 = Math.min(1, 2 * t);
            signalClusterAlpha = v1.signalClusterAlpha * (1 - t2) + v2.signalClusterAlpha * t2;

            float t3 = Math.max(0, t - 0.7f) / 0.3f;
            batteryLevelAlpha = v1.batteryLevelAlpha * (1 - t3) + v2.batteryLevelAlpha * t3;
            settingsAlpha = v1.settingsAlpha * (1 - t3) + v2.settingsAlpha * t3;
            dateExpandedAlpha = v1.dateExpandedAlpha * (1 - t3) + v2.dateExpandedAlpha * t3;
            dateCollapsedAlpha = v1.dateCollapsedAlpha * (1 - t3) + v2.dateCollapsedAlpha * t3;
            alarmStatusAlpha = v1.alarmStatusAlpha * (1 - t3) + v2.alarmStatusAlpha * t3;
        }
    }
}
